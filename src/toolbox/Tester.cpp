/* ========================================================================= *
 *                                                                           *
 *                                 SMPL++                                    *
 *                    Copyright (c) 2018, Chongyi Zheng.                     *
 *                          All Rights reserved.                             *
 *                                                                           *
 * ------------------------------------------------------------------------- *
 *                                                                           *
 * This software implements a 3D human skinning model - SMPL: A Skinned      *
 * Multi-Person Linear Model with C++.                                       *
 *                                                                           *
 * For more detail, see the paper published by Max Planck Institute for      *
 * Intelligent Systems on SIGGRAPH ASIA 2015.                                *
 *                                                                           *
 * We provide this software for research purposes only.                      *
 * The original SMPL model is available at http://smpl.is.tue.mpg.           *
 *                                                                           *
 * ========================================================================= */

//=============================================================================
//
//  CLASS Tester IMPLEMENTATIONS
//
//=============================================================================

//===== EXTERNAL MACROS =======================================================

//===== INCLUDES ==============================================================

//----------
#include <fstream>
//----------
#include <xtensor/xarray.hpp>
#include <xtensor/xjson.hpp>
//----------
#include <smpl/BlendShape.h>
#include <smpl/JointRegression.h>
#include <smpl/LinearBlendSkinning.h>
#include <smpl/WorldTransformation.h>
#include <smpl/definition/def.h>
#include <smpl/toolbox/Exception.h>
#include <smpl/toolbox/Singleton.hpp>
#include <smpl/toolbox/Tester.h>
#include <smpl/toolbox/TorchEx.hpp>
//----------

//===== EXTERNAL FORWARD DECLARATIONS =========================================

//===== NAMESPACES ============================================================

namespace smpl
{

//===== INTERNAL MACROS =======================================================

//===== INTERNAL FORWARD DECLARATIONS =========================================

//===== CLASS IMPLEMENTATIONS =================================================

/**Tester
 *
 * Brief
 * ----------
 *
 *      Default constructor.
 *
 * Arguments
 * ----------
 *
 *
 * Return
 * ----------
 *
 *
 */
Tester::Tester() noexcept(true) : m__device(torch::kCPU) {}

/**Tester (overload)
 *
 * Brief
 * ----------
 *
 *      Copy constructor.
 *
 * Arguments
 * ----------
 *
 *      @tester: - const Testet & -
 *          The tester to copy with.
 *
 * Return
 * ----------
 *
 *
 */
Tester::Tester(const Tester & tester) noexcept(true) : m__device(torch::kCPU)
{
  *this = tester;
}

/**~Tester
 *
 * Brief
 * ----------
 *
 *      Destructor.
 *
 * Arguments
 * ----------
 *
 *
 * Return
 * ----------
 *
 *
 */
Tester::~Tester() noexcept(true) {}

/**operator=
 *
 * Brief
 * ----------
 *
 *      Assignment operator is used to copy an tester.
 *
 * Arguments
 * ----------
 *
 *      @tester: - const Tester & -
 *          The tester to copy with.
 *
 * Return
 * ----------
 *
 *      @*this: - Tester & -
 *          Current instantiation.
 *
 */
Tester & Tester::operator=(const Tester & tester) noexcept(false)
{
  if(tester.m__device.has_index())
  {
    m__device = tester.m__device;
  }
  else
  {
    throw smpl_error("Tester", "Failed to fetch device index!");
  }

  return *this;
}

/**setDevice
 *
 * Brief
 * ----------
 *
 *      Set the torch device.
 *
 * Arguments
 * ----------
 *
 *
 * Return
 * ----------
 *
 */
void Tester::setDevice(const torch::Device & device) noexcept(false)
{
  if(device.has_index())
  {
    m__device = device;
  }
  else
  {
    throw smpl_error("Tester", "Failed to fetch device index!");
  }

  return;
}

/**singleton
 *
 * Brief
 * ----------
 *
 *      Test the <Singleton> module.
 *
 * Arguments
 * ----------
 *
 *
 * Return
 * ----------
 *
 *
 */
void Tester::singleton() noexcept(true)
{
  std::cout << "---------- <Singleton> Test ----------" << std::endl;

  const int * intPtr1 = Singleton<int>::get();
  const int * intPtr2 = Singleton<int>::get();
  const float * floatPtr1 = Singleton<float>::get();
  const float * floatPtr2 = Singleton<float>::get();
  assert(intPtr1 == intPtr2);
  assert(floatPtr1 == floatPtr2);

  std::cout << "intPtr1: " << intPtr1 << std::endl;
  std::cout << "intPtr2: " << intPtr2 << std::endl;
  std::cout << std::endl;

  std::cout << "floatPtr1: " << floatPtr1 << std::endl;
  std::cout << "floatPtr2: " << floatPtr2 << std::endl;
  std::cout << std::endl;

  Singleton<int>::destroy();
  Singleton<float>::destroy();

  std::cout << "PASS!" << std::endl;
  std::cout << "--------------------------------------" << std::endl;

  return;
}

/**import
 *
 * Brief
 * ----------
 *
 *      Test file reading module.
 *
 * Arguments
 * ----------
 *
 *
 * Return
 * ----------
 *
 *
 */
void Tester::import() noexcept(true)
{
  std::cout << "---------- Import Test ----------" << std::endl;

  std::ifstream file("../data/smpl_female.json");

  nlohmann::json model;
  file >> model;

  xt::xarray<int64_t> kinematicTree_;
  xt::from_json(model["kinematic_tree"], kinematicTree_);

  /**correct result
   *
   * - kinematicTree: [2, 24]
   *      [
   *          [4294967295, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8,
   *          9, 9, 9, 12, 13, 14, 16, 17, 18, 19, 20, 21],
   *          [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,
   *          12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23]
   *      ]
   */
  torch::Tensor kinematicTree = torch::from_blob(kinematicTree_.data(), {2, JOINT_NUM}, torch::kInt64).to(m__device);

  std::cout << "kinematic tree: " << kinematicTree.sizes() << std::endl;
  std::cout << kinematicTree << std::endl;

  std::cout << "PASS!" << std::endl;
  std::cout << "---------------------------------" << std::endl;

  return;
}

/**blendShape
 *
 * Brief
 * ----------
 *
 *      Test the <BlendShape> module.
 *
 * Arguments
 * ----------
 *
 *
 * Return
 * ----------
 *
 *
 * Notes
 * ----------
 *
 *      We need to set both BATCH_SIZE and VERTEX_NUM in "definition/def.h" to
 *      1 to make it compatible with this test.
 *      This kind of random number is generated by numpy with random seed 0.
 *
 */
void Tester::blendShape() noexcept(true)
{
  int batchSize = BATCH_SIZE;
  int vertexNum = VERTEX_NUM;
  BATCH_SIZE = 1;
  VERTEX_NUM = 1;

  std::cout << "---------- <BlendShape> Test ----------" << std::endl;

  xt::xarray<float> theta_{{{0.79172504, 0.52889492, 0.56804456}, {0.92559664, 0.07103606, 0.0871293},
                            {0.0202184, 0.83261985, 0.77815675},  {0.87001215, 0.97861834, 0.79915856},
                            {0.46147936, 0.78052918, 0.11827443}, {0.63992102, 0.14335329, 0.94466892},
                            {0.52184832, 0.41466194, 0.26455561}, {0.77423369, 0.45615033, 0.56843395},
                            {0.0187898, 0.6176355, 0.61209572},   {0.616934, 0.94374808, 0.6818203},
                            {0.3595079, 0.43703195, 0.6976312},   {0.06022547, 0.66676672, 0.67063787},
                            {0.21038256, 0.1289263, 0.31542835},  {0.36371077, 0.57019677, 0.43860151},
                            {0.98837384, 0.10204481, 0.20887676}, {0.16130952, 0.65310833, 0.2532916},
                            {0.46631077, 0.24442559, 0.15896958}, {0.11037514, 0.65632959, 0.13818295},
                            {0.19658236, 0.36872517, 0.82099323}, {0.09710128, 0.83794491, 0.09609841},
                            {0.97645947, 0.4686512, 0.97676109},  {0.60484552, 0.73926358, 0.03918779},
                            {0.28280696, 0.12019656, 0.2961402},  {0.11872772, 0.31798318, 0.41426299}}}; // (1, 24, 3)
  torch::Tensor theta = torch::from_blob(theta_.data(), {BATCH_SIZE, JOINT_NUM, 3}).to(m__device);

  xt::xarray<float> beta_{{0.5488135, 0.71518937, 0.60276338, 0.54488318, 0.4236548, 0.64589411, 0.43758721, 0.891773,
                           0.96366276, 0.38344152}}; // (1, 10)
  torch::Tensor beta = torch::from_blob(beta_.data(), {BATCH_SIZE, SHAPE_BASIS_DIM}).to(m__device);

  xt::xarray<float> poseBlendBasis_{
      {{0.0641475,  0.69247212, 0.56660145, 0.26538949, 0.52324805, 0.09394051, 0.5759465,  0.9292962,  0.31856895,
        0.66741038, 0.13179786, 0.7163272,  0.28940609, 0.18319136, 0.58651293, 0.02010755, 0.82894003, 0.00469548,
        0.67781654, 0.27000797, 0.73519402, 0.96218855, 0.24875314, 0.57615733, 0.59204193, 0.57225191, 0.22308163,
        0.95274901, 0.44712538, 0.84640867, 0.69947928, 0.29743695, 0.81379782, 0.39650574, 0.8811032,  0.58127287,
        0.88173536, 0.69253159, 0.72525428, 0.50132438, 0.95608363, 0.6439902,  0.42385505, 0.60639321, 0.0191932,
        0.30157482, 0.66017354, 0.29007761, 0.61801543, 0.4287687,  0.13547406, 0.29828233, 0.56996491, 0.59087276,
        0.57432525, 0.65320082, 0.65210327, 0.43141844, 0.8965466,  0.36756187, 0.43586493, 0.89192336, 0.80619399,
        0.70388858, 0.10022689, 0.91948261, 0.7142413,  0.99884701, 0.1494483,  0.86812606, 0.16249293, 0.61555956,
        0.12381998, 0.84800823, 0.80731896, 0.56910074, 0.4071833,  0.069167,   0.69742877, 0.45354268, 0.7220556,
        0.86638233, 0.97552151, 0.85580334, 0.01171408, 0.35997806, 0.72999056, 0.17162968, 0.52103661, 0.05433799,
        0.19999652, 0.01852179, 0.7936977,  0.22392469, 0.34535168, 0.92808129, 0.7044144,  0.03183893, 0.16469416,
        0.6214784,  0.57722859, 0.23789282, 0.934214,   0.61396596, 0.5356328,  0.58990998, 0.73012203, 0.311945,
        0.39822106, 0.20984375, 0.18619301, 0.94437239, 0.7395508,  0.49045881, 0.22741463, 0.25435648, 0.05802916,
        0.43441663, 0.31179588, 0.69634349, 0.37775184, 0.17960368, 0.02467873, 0.06724963, 0.67939277, 0.45369684,
        0.53657921, 0.89667129, 0.99033895, 0.21689698, 0.6630782,  0.26332238, 0.020651,   0.75837865, 0.32001715,
        0.38346389, 0.58831711, 0.83104846, 0.62898184, 0.87265066, 0.27354203, 0.79804683, 0.18563594, 0.95279166,
        0.68748828, 0.21550768, 0.94737059, 0.73085581, 0.25394164, 0.21331198, 0.51820071, 0.02566272, 0.20747008,
        0.42468547, 0.37416998, 0.46357542, 0.27762871, 0.58678435, 0.86385561, 0.11753186, 0.51737911, 0.13206811,
        0.71685968, 0.3960597,  0.56542131, 0.18327984, 0.14484776, 0.48805628, 0.35561274, 0.94043195, 0.76532525,
        0.74866362, 0.90371974, 0.08342244, 0.55219247, 0.58447607, 0.96193638, 0.29214753, 0.24082878, 0.10029394,
        0.01642963, 0.92952932, 0.66991655, 0.78515291, 0.28173011, 0.58641017, 0.06395527, 0.4856276,  0.97749514,
        0.87650525, 0.33815895, 0.96157015, 0.23170163, 0.94931882, 0.9413777,  0.79920259, 0.63044794, 0.87428797,
        0.29302028, 0.84894356, 0.61787669, 0.01323686, 0.34723352, 0.14814086, 0.98182939, 0.47837031, 0.49739137},

       {0.63947252, 0.36858461, 0.13690027, 0.82211773, 0.18984791, 0.51131898, 0.22431703, 0.09784448, 0.86219152,
        0.97291949, 0.96083466, 0.9065555,  0.77404733, 0.33314515, 0.08110139, 0.40724117, 0.23223414, 0.13248763,
        0.05342718, 0.72559436, 0.01142746, 0.77058075, 0.14694665, 0.07952208, 0.08960303, 0.67204781, 0.24536721,
        0.42053947, 0.55736879, 0.86055117, 0.72704426, 0.27032791, 0.1314828,  0.05537432, 0.30159863, 0.26211815,
        0.45614057, 0.68328134, 0.69562545, 0.28351885, 0.37992696, 0.18115096, 0.78854551, 0.05684808, 0.69699724,
        0.7786954,  0.77740756, 0.25942256, 0.37381314, 0.58759964, 0.2728219,  0.3708528,  0.19705428, 0.45985588,
        0.0446123,  0.79979588, 0.07695645, 0.51883515, 0.3068101,  0.57754295, 0.95943334, 0.64557024, 0.03536244,
        0.43040244, 0.51001685, 0.53617749, 0.68139251, 0.2775961,  0.12886057, 0.39267568, 0.95640572, 0.18713089,
        0.90398395, 0.54380595, 0.45691142, 0.88204141, 0.45860396, 0.72416764, 0.39902532, 0.90404439, 0.69002502,
        0.69962205, 0.3277204,  0.75677864, 0.63606106, 0.24002027, 0.16053882, 0.79639147, 0.9591666,  0.45813883,
        0.59098417, 0.85772264, 0.45722345, 0.95187448, 0.57575116, 0.82076712, 0.90884372, 0.81552382, 0.15941446,
        0.62889844, 0.39843426, 0.06271295, 0.42403225, 0.25868407, 0.84903831, 0.03330463, 0.95898272, 0.35536885,
        0.35670689, 0.0163285,  0.18523233, 0.4012595,  0.92929142, 0.09961493, 0.94530153, 0.86948853, 0.4541624,
        0.32670088, 0.23274413, 0.61446471, 0.03307459, 0.01560606, 0.42879572, 0.06807407, 0.25194099, 0.22116092,
        0.25319119, 0.13105523, 0.01203622, 0.1154843,  0.61848026, 0.97425621, 0.990345,   0.4090541,  0.16295443,
        0.63876176, 0.49030535, 0.98940978, 0.06530421, 0.78323444, 0.2883985,  0.24141862, 0.66250457, 0.24606318,
        0.66585912, 0.51730852, 0.42408899, 0.55468781, 0.28705152, 0.70657471, 0.41485687, 0.36054556, 0.82865691,
        0.92496691, 0.04600731, 0.23262699, 0.34851937, 0.81496648, 0.98549143, 0.9689717,  0.90494835, 0.29655627,
        0.99201124, 0.24942004, 0.10590615, 0.95095261, 0.23342026, 0.68976827, 0.05835636, 0.7307091,  0.88172021,
        0.2724369,  0.3790569,  0.37429618, 0.74878826, 0.23780724, 0.1718531,  0.44929165, 0.30446841, 0.83918912,
        0.23774183, 0.50238946, 0.9425836,  0.6339977,  0.86728941, 0.94020969, 0.75076486, 0.69957506, 0.96796557,
        0.99440079, 0.45182168, 0.07086978, 0.29279403, 0.15235471, 0.41748637, 0.13128933, 0.6041178,  0.38280806,
        0.89538588, 0.96779467, 0.5468849,  0.27482357, 0.59223042, 0.89676116, 0.40673335, 0.55207828, 0.27165277},

       {0.45544415, 0.40171354, 0.24841347, 0.50586638, 0.31038083, 0.37303486, 0.52497044, 0.75059502,
        0.33350747, 0.92415877, 0.86231855, 0.0486903,  0.25364252, 0.44613551, 0.10462789, 0.34847599,
        0.74009753, 0.68051448, 0.62238443, 0.7105284,  0.20492369, 0.34169811, 0.67624248, 0.87923476,
        0.54367805, 0.28269965, 0.03023526, 0.71033683, 0.0078841,  0.37267907, 0.53053721, 0.92211146,
        0.08949455, 0.40594232, 0.0243132,  0.34261098, 0.62223106, 0.27906795, 0.20974995, 0.11570323,
        0.57714024, 0.69527001, 0.67195714, 0.94886102, 0.00270321, 0.64719665, 0.60039224, 0.58873961,
        0.96277032, 0.01687167, 0.69648243, 0.81367865, 0.5098072,  0.33396487, 0.79084016, 0.09724293,
        0.44203564, 0.51995237, 0.69395641, 0.09088573, 0.2277595,  0.41030156, 0.62329467, 0.88696078,
        0.61882617, 0.13346147, 0.98058013, 0.87178573, 0.50272076, 0.92234798, 0.54138079, 0.92330607,
        0.82989737, 0.96828641, 0.91978281, 0.03603382, 0.174772,   0.38913468, 0.9521427,  0.30002892,
        0.16046764, 0.88630467, 0.44639442, 0.90787559, 0.16023047, 0.66111751, 0.44026375, 0.07648677,
        0.69646314, 0.24739876, 0.03961552, 0.0599443,  0.06107854, 0.90773296, 0.73988392, 0.89806236,
        0.67258231, 0.52893993, 0.30444636, 0.99796225, 0.36218906, 0.47064895, 0.37824517, 0.97952693,
        0.17465839, 0.327988,   0.68034867, 0.06320762, 0.60724937, 0.4776465,  0.28399998, 0.23841328,
        0.51451274, 0.36792758, 0.45651989, 0.33747738, 0.97049369, 0.13343943, 0.09680395, 0.34339173,
        0.5910269,  0.65917647, 0.39725675, 0.99927799, 0.351893,   0.72140667, 0.63758269, 0.81305386,
        0.97622566, 0.88979366, 0.76456197, 0.69824848, 0.33549817, 0.14768558, 0.062636,   0.2419017,
        0.43228148, 0.52199627, 0.77308355, 0.95874092, 0.11732048, 0.10700414, 0.58969472, 0.74539807,
        0.84815038, 0.93583208, 0.98342624, 0.39980169, 0.38033518, 0.14780868, 0.68493444, 0.65676196,
        0.8620626,  0.09725799, 0.49777691, 0.58108193, 0.24155704, 0.16902541, 0.85958084, 0.05853492,
        0.4706209,  0.115834,   0.45705876, 0.97996233, 0.42370635, 0.85712492, 0.11731556, 0.27125208,
        0.40379274, 0.39981214, 0.67138348, 0.34471813, 0.71376687, 0.6391869,  0.39916115, 0.43176013,
        0.6145277,  0.07004219, 0.82240674, 0.65342116, 0.72634246, 0.536923,   0.11047711, 0.40503561,
        0.40537358, 0.32104299, 0.02995032, 0.73725424, 0.10978446, 0.60630813, 0.7032175,  0.63478632,
        0.95914225, 0.10329816, 0.86716716, 0.02919023, 0.53491685, 0.40424362, 0.52418386, 0.36509988,
        0.19056691, 0.0191229,  0.51814981, 0.84277686, 0.37321596, 0.22286382, 0.080532}}}; // (1, 3, 207)
  torch::Tensor poseBlendBasis =
      torch::from_blob(poseBlendBasis_.data(), {BATCH_SIZE, 3, POSE_BASIS_DIM}).to(m__device);

  xt::xarray<float> shapeBlendBasis_{{{0.08531092, 0.22139645, 0.10001406, 0.2650397, 0.06614946, 0.06560487,
                                       0.85627618, 0.16212026, 0.55968241, 0.77345554},

                                      {0.45640957, 0.15336888, 0.19959614, 0.43298421, 0.52823409, 0.34944029,
                                       0.7814796, 0.75102165, 0.92721181, 0.02895255},

                                      {0.89569129, 0.39256879, 0.8783725, 0.69078478, 0.98734876, 0.75928245,
                                       0.36454463, 0.50106317, 0.37638916, 0.36491184}}}; // (1, 3, 10)
  torch::Tensor shapeBlendBasis =
      torch::from_blob(shapeBlendBasis_.data(), {BATCH_SIZE, 3, SHAPE_BASIS_DIM}).to(m__device);

  /**correct result
   *
   * - shapeBlendShape: [1, 3]
   *      [
   *          [1.835449, 3.082224, 3.695877]
   *      ]
   *
   * - poseBlendShape: [1, 3]
   *      [
   *          [
   *              [0.912995, -1.879041, -3.56463]
   *          ]
   *      ]
   *
   * - poseRotation: [5, 3, 3]
   *      [
   *          [
   *              [ 0.728415, -0.269833,  0.629764],
   *              [ 0.647397,  0.571931, -0.503758],
   *              [-0.224251,  0.774652,  0.591292]
   *          ],
   *          [
   *              [ 0.994126, -0.044481,  0.098667],
   *              [ 0.105604,  0.598255, -0.794316],
   *              [-0.023696,  0.80007 ,  0.599438],
   *          ],
   *          [
   *              [ 0.41794 , -0.612729,  0.670738],
   *              [ 0.627818,  0.728445,  0.274249],
   *              [-0.656636,  0.306481,  0.689129]
   *          ],
   *          [
   *              [ 0.346577, -0.172097,  0.922099],
   *              [ 0.869102,  0.428758, -0.246636],
   *              [-0.352912,  0.886876,  0.298167]
   *          ],
   *          [
   *              [ 0.70951 ,  0.065427,  0.701652],
   *              [ 0.270361,  0.894214, -0.356772],
   *              [-0.650769,  0.442832,  0.616765]
   *          ]
   *      ]
   *
   * - restPoseRotation: [1, 3, 3]
   *      [
   *          [1., 0., 0.],
   *          [0., 1., 0.],
   *          [0., 0., 1.]
   *      ]
   */

  torch::Tensor shapeBlendShape, poseBlendShape;
  torch::Tensor poseRotation, restPoseRotation;
  try
  {
    BlendShape blendShape;
    blendShape.setDevice(m__device);

    blendShape.setTheta(theta);
    blendShape.setBeta(beta);
    blendShape.setPoseBlendBasis(poseBlendBasis);
    blendShape.setShapeBlendBasis(shapeBlendBasis);

    blendShape.blend();

    shapeBlendShape = blendShape.getShapeBlendShape(); // (1, 1, 3)
    poseBlendShape = blendShape.getPoseBlendShape(); // (1, 1, 3)
    poseRotation = blendShape.getPoseRotation(); // (1, 24, 3, 3)
    restPoseRotation = blendShape.getRestPoseRotation(); // (1, 24, 3, 3)
  }
  catch(Exception & e)
  {
    std::cerr << e.what() << std::endl;
  }

  std::cout << "shape blend shape: " << shapeBlendShape.sizes() << std::endl; // (1, 1, 3)
  std::cout << shapeBlendShape << std::endl;
  std::cout << std::endl;

  std::cout << "pose blend shape: " << poseBlendShape.sizes() << std::endl; // (1, 3, 3)
  std::cout << poseBlendShape << std::endl;
  std::cout << std::endl;

  torch::Tensor poseRotSlice = TorchEx::indexing(poseRotation, torch::IntArrayRef({0}), torch::IntArrayRef({0, 5}),
                                                 torch::IntArrayRef(), torch::IntArrayRef());
  std::cout << "first five pose rotation: " << poseRotSlice.sizes() << std::endl; // (5, 3, 3)
  std::cout << poseRotSlice << std::endl; // the first five rotation
  std::cout << std::endl;

  torch::Tensor restRotSlice = TorchEx::indexing(restPoseRotation, torch::IntArrayRef(), torch::IntArrayRef({0}),
                                                 torch::IntArrayRef(), torch::IntArrayRef());
  std::cout << "first rest pose rotation: " << restRotSlice.sizes() << std::endl; // (1, 3, 3)
  std::cout << restRotSlice << std::endl; // the first rotation
  std::cout << std::endl;

  std::cout << "PASS!" << std::endl;
  std::cout << "---------------------------------------" << std::endl;

  BATCH_SIZE = batchSize;
  VERTEX_NUM = vertexNum;

  return;
}

/**jointRegression
 *
 * Brief
 * ----------
 *
 *      Test the <JointRegression> module.
 *
 * Arguments
 * ----------
 *
 *
 * Return
 * ----------
 *
 *
 * Notes
 * ----------
 *
 *      We need to set BATCH_SIZE in "definition/def.h" to 1 and VERTEX_NUM to
 *      5 to make it compatible with this test.
 *      This kind of random number is generated by numpy with random seed 0.
 *
 */
void Tester::jointRegression() noexcept(true)
{
  int batchSize = BATCH_SIZE;
  int vertexNum = VERTEX_NUM;
  BATCH_SIZE = 1;
  VERTEX_NUM = 5;

  std::cout << "---------- <JointRegression> Test ----------" << std::endl;

  xt::xarray<float> templateShape_{{0.5488135, 0.71518937, 0.60276338},
                                   {0.54488318, 0.4236548, 0.64589411},
                                   {0.43758721, 0.891773, 0.96366276},
                                   {0.38344152, 0.79172504, 0.52889492},
                                   {0.56804456, 0.92559664, 0.07103606}}; // (5, 3)
  torch::Tensor templateShape = torch::from_blob(templateShape_.data(), {VERTEX_NUM, 3}).to(m__device);

  xt::xarray<float> jointRegressor_{{0.0871293, 0.0202184, 0.83261985, 0.77815675, 0.87001215},
                                    {0.97861834, 0.79915856, 0.46147936, 0.78052918, 0.11827443},
                                    {0.63992102, 0.14335329, 0.94466892, 0.52184832, 0.41466194},
                                    {0.26455561, 0.77423369, 0.45615033, 0.56843395, 0.0187898},
                                    {0.6176355, 0.61209572, 0.616934, 0.94374808, 0.6818203},
                                    {0.3595079, 0.43703195, 0.6976312, 0.06022547, 0.66676672},
                                    {0.67063787, 0.21038256, 0.1289263, 0.31542835, 0.36371077},
                                    {0.57019677, 0.43860151, 0.98837384, 0.10204481, 0.20887676},
                                    {0.16130952, 0.65310833, 0.2532916, 0.46631077, 0.24442559},
                                    {0.15896958, 0.11037514, 0.65632959, 0.13818295, 0.19658236},
                                    {0.36872517, 0.82099323, 0.09710128, 0.83794491, 0.09609841},
                                    {0.97645947, 0.4686512, 0.97676109, 0.60484552, 0.73926358},
                                    {0.03918779, 0.28280696, 0.12019656, 0.2961402, 0.11872772},
                                    {0.31798318, 0.41426299, 0.0641475, 0.69247212, 0.56660145},
                                    {0.26538949, 0.52324805, 0.09394051, 0.5759465, 0.9292962},
                                    {0.31856895, 0.66741038, 0.13179786, 0.7163272, 0.28940609},
                                    {0.18319136, 0.58651293, 0.02010755, 0.82894003, 0.00469548},
                                    {0.67781654, 0.27000797, 0.73519402, 0.96218855, 0.24875314},
                                    {0.57615733, 0.59204193, 0.57225191, 0.22308163, 0.95274901},
                                    {0.44712538, 0.84640867, 0.69947928, 0.29743695, 0.81379782},
                                    {0.39650574, 0.8811032, 0.58127287, 0.88173536, 0.69253159},
                                    {0.72525428, 0.50132438, 0.95608363, 0.6439902, 0.42385505},
                                    {0.60639321, 0.0191932, 0.30157482, 0.66017354, 0.29007761},
                                    {0.61801543, 0.4287687, 0.13547406, 0.29828233, 0.56996491}}; // (24, 5)
  torch::Tensor jointRegressor = torch::from_blob(jointRegressor_.data(), {JOINT_NUM, VERTEX_NUM}).to(m__device);

  xt::xarray<float> shapeBlendShape_{{{0.1494483, 0.86812606, 0.16249293},
                                      {0.61555956, 0.12381998, 0.84800823},
                                      {0.80731896, 0.56910074, 0.4071833},
                                      {0.069167, 0.69742877, 0.45354268},
                                      {0.7220556, 0.86638233, 0.97552151}}}; // (1, 5, 3)
  torch::Tensor shapeBlendShape = torch::from_blob(shapeBlendShape_.data(), {BATCH_SIZE, VERTEX_NUM, 3}).to(m__device);

  xt::xarray<float> poseBlendShape_{{{0.59087276, 0.57432525, 0.65320082},
                                     {0.65210327, 0.43141844, 0.8965466},
                                     {0.36756187, 0.43586493, 0.89192336},
                                     {0.80619399, 0.70388858, 0.10022689},
                                     {0.91948261, 0.7142413, 0.99884701}}}; // (1, 5, 3)
  torch::Tensor poseBlendShape = torch::from_blob(poseBlendShape_.data(), {BATCH_SIZE, VERTEX_NUM, 3}).to(m__device);

  /**correct results
   *
   * - restShape: (1, 5, 3)
   *      [
   *          [
   *              [1.289135, 2.157641, 1.418457],
   *              [1.812546, 0.978893, 2.390449],
   *              [1.612468, 1.896739, 2.262769],
   *              [1.258803, 2.193042, 1.082664],
   *              [2.209583, 2.50622 , 2.045405]
   *          ]
   *      ]
   *
   * - joints: (1, 24, 3)
   *      [
   *          [2.595438, 4.083213, 2.913282],
   *          [2.691068, 4.035417, 3.465978],
   *          [2.560358, 3.991899, 2.945506],
   *          [1.932566, 2.389283, 2.56251 ],
   *          [3.216363, 4.841475, 3.87352 ],
   *          [2.514121, 3.112146, 2.641321],
   *          [1.484908, 2.486839, 1.694772],
   *          [2.45321 , 3.113077, 2.765337],
   *          [1.712245, 2.115405, 2.160274],
   *          [1.372309, 1.828988, 1.52776 ],
   *          [1.834302, 2.595169, 2.565565],
   *          [3.669125, 5.454995, 4.154255],
   *          [0.792384, 1.046224, 1.03244 ],
   *          [1.827013, 2.870513, 2.223435],
   *          [2.369021, 3.366848, 2.651944],
   *          [1.858591, 2.647657, 2.428134],
   *          [1.214805, 1.883359, 1.863242],
   *          [2.458281, 4.173653, 3.135531],
   *          [3.13185 , 4.111864, 3.326101],
   *          [3.349709, 4.094417, 3.709395],
   *          [3.315481, 4.513383, 4.00757 ],
   *          [3.116701, 4.538026, 3.690847],
   *          [1.494156, 2.914095, 1.858294],
   *          [1.968068, 2.876717, 2.188738]
   *      ]
   *
   */

  torch::Tensor restShape, joints;
  try
  {
    JointRegression jointRegression;
    jointRegression.setDevice(m__device);

    jointRegression.setShapeBlendShape(shapeBlendShape);
    jointRegression.setPoseBlendShape(poseBlendShape);
    jointRegression.setTemplateRestShape(templateShape);
    jointRegression.setJointRegressor(jointRegressor);

    jointRegression.regress();

    restShape = jointRegression.getRestShape();
    joints = jointRegression.getJoint();
  }
  catch(std::exception & e)
  {
    std::cerr << e.what() << std::endl;
  }

  std::cout << "deformed shape in rest pose: ";
  std::cout << restShape.sizes() << std::endl; // (1, 5, 3)
  std::cout << restShape << std::endl;
  std::cout << std::endl;

  std::cout << "joints of deformed shape: ";
  std::cout << joints.sizes() << std::endl; // (1, 24, 3)
  std::cout << joints << std::endl;
  std::cout << std::endl;

  std::cout << "PASS!" << std::endl;
  std::cout << "--------------------------------------------" << std::endl;

  BATCH_SIZE = batchSize;
  VERTEX_NUM = vertexNum;

  return;
}

/**worldTransformation
 *
 * Brief
 * ----------
 *
 *      Test the <WorldTransformation> module.
 *
 * Arguments
 * ----------
 *
 *
 * Return
 * ----------
 *
 *
 * Notes
 * ----------
 *
 *      We need to set BATCH_SIZE in "definition/def.h" to 1 to make it
 *      compatible with this test.
 *      This kind of random number is generated by numpy with random seed 0.
 *
 */
void Tester::worldTransformation() noexcept(true)
{
  int batchSize = BATCH_SIZE;
  BATCH_SIZE = 1;

  std::cout << "---------- <WorldTransformation> Test ----------" << std::endl;

  /**
   *
   * This array is exactly the kinematic tree of SMPL.
   *
   *      first row - ancestor index
   *      second row - joint indices
   *
   *      Note: Joint with ancestor index as 4294967295 is indeed root at
   *            the belly button.
   *
   */
  xt::xarray<int64_t> kineTree_{
      {4294967295, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 9, 9, 12, 13, 14, 16, 17, 18, 19, 20, 21},
      {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23}}; // (2, 24)
  torch::Tensor kineTree = torch::from_blob(kineTree_.data(), {2, JOINT_NUM}, torch::kInt64).to(m__device);

  xt::xarray<float> joints_{{{0.5488135, 0.71518937, 0.60276338},  {0.54488318, 0.4236548, 0.64589411},
                             {0.43758721, 0.891773, 0.96366276},   {0.38344152, 0.79172504, 0.52889492},
                             {0.56804456, 0.92559664, 0.07103606}, {0.0871293, 0.0202184, 0.83261985},
                             {0.77815675, 0.87001215, 0.97861834}, {0.79915856, 0.46147936, 0.78052918},
                             {0.11827443, 0.63992102, 0.14335329}, {0.94466892, 0.52184832, 0.41466194},
                             {0.26455561, 0.77423369, 0.45615033}, {0.56843395, 0.0187898, 0.6176355},
                             {0.61209572, 0.616934, 0.94374808},   {0.6818203, 0.3595079, 0.43703195},
                             {0.6976312, 0.06022547, 0.66676672},  {0.67063787, 0.21038256, 0.1289263},
                             {0.31542835, 0.36371077, 0.57019677}, {0.43860151, 0.98837384, 0.10204481},
                             {0.20887676, 0.16130952, 0.65310833}, {0.2532916, 0.46631077, 0.24442559},
                             {0.15896958, 0.11037514, 0.65632959}, {0.13818295, 0.19658236, 0.36872517},
                             {0.82099323, 0.09710128, 0.83794491}, {0.09609841, 0.97645947, 0.4686512}}}; // (1, 24, 3)
  torch::Tensor joints = torch::from_blob(joints_.data(), {BATCH_SIZE, JOINT_NUM, 3}).to(m__device);

  xt::xarray<float> poseRotation_{
      {{{0.95627849, 0.89187929, 0.90854612},
        {0.03836603, 0.41701503, 0.14772014},
        {0.28993016, 0.17507081, 0.39079753}},
       {{0.58499362, 0.10064153, 0.54457918},
        {0.80011548, 0.41637173, 0.41149671},
        {0.13265631, 0.90360714, 0.73082417}},
       {{0.32537401, 0.91710756, 0.15341195},
        {0.73162891, 0.39768113, 0.21323369},
        {0.59904164, 0.02763035, 0.96488143}},
       {{0.00502689, 0.51447925, 0.39713296},
        {0.78708538, 0.73032452, 0.36587094},
        {0.61682359, 0.44937423, 0.84167919}},
       {{0.18665207, 0.7642271, 0.43332029}, {0.70818889, 0.56107224, 0.28825352}, {0.68090344, 0.31804854, 0.85389896}},
       {{0.51405964, 0.80209599, 0.52180655},
        {0.64139231, 0.45604417, 0.72038693},
        {0.56952489, 0.38557196, 0.45690327}},
       {{0.05984255, 0.4023277, 0.67928159}, {0.90443419, 0.8244877, 0.44117897}, {0.42239515, 0.39793523, 0.58646196}},
       {{0.61958306, 0.68355122, 0.45891009}, {0.68378874, 0.51346619, 0.6298741}, {0.38542157, 0.51875832, 0.62662601}},
       {{0.65439811, 0.53069018, 0.09855839},
        {0.74635595, 0.53849551, 0.98221896},
        {0.12130913, 0.65451548, 0.15978788}},
       {{0.60492718, 0.13627062, 0.81201472}, {0.79337436, 0.62632629, 0.3899005}, {0.06797229, 0.76755827, 0.43429217}},
       {{0.54019544, 0.98085134, 0.83875517}, {0.64025688, 0.01326178, 0.3095098}, {0.54613187, 0.1943059, 0.44798822}},
       {{0.04445216, 0.26118456, 0.05332922}, {0.64929854, 0.29243343, 0.99436014}, {0.75923343, 0.9199268, 0.09167282}},
       {{0.27052909, 0.49025286, 0.51769376},
        {0.39076631, 0.73695414, 0.55064207},
        {0.87983846, 0.46535012, 0.65481791}},
       {{0.51109183, 0.37932067, 0.25915189}, {0.30505931, 0.89955053, 0.9133271}, {0.80356951, 0.21662106, 0.31412402}},
       {{0.0829945, 0.74951041, 0.40556339}, {0.99592475, 0.65174516, 0.23361654}, {0.03529602, 0.11602755, 0.88370903}},
       {{0.40483631, 0.92653125, 0.66487067},
        {0.88368515, 0.37452408, 0.49166429},
        {0.23496407, 0.03565885, 0.56232839}},
       {{0.34351363, 0.35307573, 0.5505034}, {0.89206617, 0.57913725, 0.81656158}, {0.29362619, 0.73480444, 0.17370431}},
       {{0.70035022, 0.60877291, 0.64513862}, {0.69636546, 0.64717498, 0.76019362}, {0.15679513, 0.45886827, 0.0768233}},
       {{0.20703653, 0.81542342, 0.4314793}, {0.4626067, 0.53306498, 0.67665851}, {0.86205042, 0.22566872, 0.59662289}},
       {{0.17411446, 0.87321991, 0.3842784}, {0.74543378, 0.22325653, 0.14053908}, {0.64343814, 0.43317839, 0.9124576}},
       {{0.6211688, 0.76780402, 0.81942615}, {0.06770901, 0.56630987, 0.52995963}, {0.78074631, 0.2996166, 0.21836571}},
       {{0.11194162, 0.02085178, 0.85598015},
        {0.74771759, 0.99648219, 0.25943816},
        {0.65451316, 0.08116926, 0.44720223}},
       {{0.58771193, 0.72523405, 0.28447649},
        {0.57813715, 0.19171352, 0.79861522},
        {0.56599658, 0.66127263, 0.53036483}},
       {{0.80893773, 0.28595511, 0.82066083},
        {0.57169238, 0.0129177, 0.33566536},
        {0.1370678, 0.95815594, 0.46243331}}}}; // (1, 24, 3, 3)
  torch::Tensor poseRotation = torch::from_blob(poseRotation_.data(), {BATCH_SIZE, JOINT_NUM, 3, 3});

  /**correct results
   *
   * - transformations: (1, 5, 4, 4)
   *      [
   *          [
   *              [ 0.956278,  0.891879,  0.908546, -1.161506],
   *              [ 0.038366,  0.417015,  0.14772 ,  0.306849],
   *              [ 0.28993 ,  0.175071,  0.390798,  0.082879],
   *              [ 0.      ,  0.      ,  0.      ,  1.      ]
   *          ],
   *          [
   *              [ 1.393548,  1.288563,  1.551762, -1.983273],
   *              [ 0.3757  ,  0.310975,  0.300451,  0.069317],
   *              [ 0.361526,  0.455201,  0.515535, -0.155379],
   *              [ 0.      ,  0.      ,  0.      ,  1.      ]
   *          ],
   *          [
   *              [ 1.50793 ,  1.256797,  1.213523, -2.02222 ],
   *              [ 0.406074,  0.205106,  0.23734 ,  0.248555],
   *              [ 0.456527,  0.346317,  0.458883, -0.208346],
   *              [ 0.      ,  0.      ,  0.      ,  1.      ]
   *          ],
   *          [
   *              [ 1.267205,  1.551624,  1.470787, -2.100431],
   *              [ 0.419537,  0.390676,  0.292143,  0.10516 ],
   *              [ 0.380306,  0.452636,  0.50812 , -0.233582],
   *              [ 0.      ,  0.      ,  0.      ,  1.      ]
   *          ],
   *          [
   *              [ 2.229255,  2.2815  ,  2.300334, -3.430226],
   *              [ 0.494933,  0.557158,  0.508993, -0.241092],
   *              [ 0.740878,  0.695654,  0.728085, -0.608528],
   *              [ 0.      ,  0.      ,  0.      ,  1.      ]
   *          ]
   *      ]
   *
   *
   */

  torch::Tensor transformations;
  try
  {
    WorldTransformation worldTransformation;
    worldTransformation.setDevice(m__device);

    worldTransformation.setKinematicTree(kineTree);
    worldTransformation.setJoint(joints);
    worldTransformation.setPoseRotation(poseRotation);

    worldTransformation.transform();

    transformations = worldTransformation.getTransformation();
  }
  catch(std::exception & e)
  {
    std::cerr << e.what() << std::endl;
  }

  torch::Tensor slice =
      TorchEx::indexing(transformations, torch::IntArrayRef(), torch::IntArrayRef({0, 5}), torch::IntArrayRef());
  std::cout << "first five pose rotation: " << slice.sizes() << std::endl; // (1, 5, 4, 4)
  std::cout << slice << std::endl;

  std::cout << "PASS!" << std::endl;
  std::cout << "------------------------------------------------" << std::endl;

  BATCH_SIZE = batchSize;

  return;
}

/**linearBlendSkinning
 *
 * Brief
 * ----------
 *
 *      Test the <LinearBlendSkinng> module.
 *
 * Arguments
 * ----------
 *
 *
 * Return
 * ----------
 *
 *
 * Notes
 * ----------
 *
 *      We need to set both BATCH_SIZE and VERTEX_NUM in "definition/def.h" to
 *      1 to make it compatible with this test.
 *      This kind of random number is generated by numpy with random seed 0.
 *
 */
void Tester::linearBlendSkinning() noexcept(true)
{
  int batchSize = BATCH_SIZE;
  int vertexNum = VERTEX_NUM;
  BATCH_SIZE = 1;
  VERTEX_NUM = 1;

  std::cout << "---------- <LinearBlendSkinning> Test ----------" << std::endl;

  xt::xarray<float> weights_{{0.5488135,  0.71518937, 0.60276338, 0.54488318, 0.4236548,  0.64589411,
                              0.43758721, 0.891773,   0.96366276, 0.38344152, 0.79172504, 0.52889492,
                              0.56804456, 0.92559664, 0.07103606, 0.0871293,  0.0202184,  0.83261985,
                              0.77815675, 0.87001215, 0.97861834, 0.79915856, 0.46147936, 0.78052918}}; // (1, 24)
  torch::Tensor weights = torch::from_blob(weights_.data(), {BATCH_SIZE, JOINT_NUM}).to(m__device);

  xt::xarray<float> restShape_{{{0.11827443, 0.63992102, 0.14335329}}}; // (1, 1, 3)
  torch::Tensor restShape = torch::from_blob(restShape_.data(), {BATCH_SIZE, VERTEX_NUM, 3}).to(m__device);

  xt::xarray<float> transformations_{{{{0.94466892, 0.52184832, 0.41466194, 0.26455561},
                                       {0.77423369, 0.45615033, 0.56843395, 0.0187898},
                                       {0.6176355, 0.61209572, 0.616934, 0.94374808},
                                       {0.6818203, 0.3595079, 0.43703195, 0.6976312}},

                                      {{0.06022547, 0.66676672, 0.67063787, 0.21038256},
                                       {0.1289263, 0.31542835, 0.36371077, 0.57019677},
                                       {0.43860151, 0.98837384, 0.10204481, 0.20887676},
                                       {0.16130952, 0.65310833, 0.2532916, 0.46631077}},
                                      {{0.24442559, 0.15896958, 0.11037514, 0.65632959},
                                       {0.13818295, 0.19658236, 0.36872517, 0.82099323},
                                       {0.09710128, 0.83794491, 0.09609841, 0.97645947},
                                       {0.4686512, 0.97676109, 0.60484552, 0.73926358}},
                                      {{0.03918779, 0.28280696, 0.12019656, 0.2961402},
                                       {0.11872772, 0.31798318, 0.41426299, 0.0641475},
                                       {0.69247212, 0.56660145, 0.26538949, 0.52324805},
                                       {0.09394051, 0.5759465, 0.9292962, 0.31856895}},
                                      {{0.66741038, 0.13179786, 0.7163272, 0.28940609},
                                       {0.18319136, 0.58651293, 0.02010755, 0.82894003},
                                       {0.00469548, 0.67781654, 0.27000797, 0.73519402},
                                       {0.96218855, 0.24875314, 0.57615733, 0.59204193}},
                                      {{0.57225191, 0.22308163, 0.95274901, 0.44712538},
                                       {0.84640867, 0.69947928, 0.29743695, 0.81379782},
                                       {0.39650574, 0.8811032, 0.58127287, 0.88173536},
                                       {0.69253159, 0.72525428, 0.50132438, 0.95608363}},
                                      {{0.6439902, 0.42385505, 0.60639321, 0.0191932},
                                       {0.30157482, 0.66017354, 0.29007761, 0.61801543},
                                       {0.4287687, 0.13547406, 0.29828233, 0.56996491},
                                       {0.59087276, 0.57432525, 0.65320082, 0.65210327}},
                                      {{0.43141844, 0.8965466, 0.36756187, 0.43586493},
                                       {0.89192336, 0.80619399, 0.70388858, 0.10022689},
                                       {0.91948261, 0.7142413, 0.99884701, 0.1494483},
                                       {0.86812606, 0.16249293, 0.61555956, 0.12381998}},
                                      {{0.84800823, 0.80731896, 0.56910074, 0.4071833},
                                       {0.069167, 0.69742877, 0.45354268, 0.7220556},
                                       {0.86638233, 0.97552151, 0.85580334, 0.01171408},
                                       {0.35997806, 0.72999056, 0.17162968, 0.52103661}},
                                      {{0.05433799, 0.19999652, 0.01852179, 0.7936977},
                                       {0.22392469, 0.34535168, 0.92808129, 0.7044144},
                                       {0.03183893, 0.16469416, 0.6214784, 0.57722859},
                                       {0.23789282, 0.934214, 0.61396596, 0.5356328}},
                                      {{0.58990998, 0.73012203, 0.311945, 0.39822106},
                                       {0.20984375, 0.18619301, 0.94437239, 0.7395508},
                                       {0.49045881, 0.22741463, 0.25435648, 0.05802916},
                                       {0.43441663, 0.31179588, 0.69634349, 0.37775184}},
                                      {{0.17960368, 0.02467873, 0.06724963, 0.67939277},
                                       {0.45369684, 0.53657921, 0.89667129, 0.99033895},
                                       {0.21689698, 0.6630782, 0.26332238, 0.020651},
                                       {0.75837865, 0.32001715, 0.38346389, 0.58831711}},
                                      {{0.83104846, 0.62898184, 0.87265066, 0.27354203},
                                       {0.79804683, 0.18563594, 0.95279166, 0.68748828},
                                       {0.21550768, 0.94737059, 0.73085581, 0.25394164},
                                       {0.21331198, 0.51820071, 0.02566272, 0.20747008}},
                                      {{0.42468547, 0.37416998, 0.46357542, 0.27762871},
                                       {0.58678435, 0.86385561, 0.11753186, 0.51737911},
                                       {0.13206811, 0.71685968, 0.3960597, 0.56542131},
                                       {0.18327984, 0.14484776, 0.48805628, 0.35561274}},
                                      {{0.94043195, 0.76532525, 0.74866362, 0.90371974},
                                       {0.08342244, 0.55219247, 0.58447607, 0.96193638},
                                       {0.29214753, 0.24082878, 0.10029394, 0.01642963},
                                       {0.92952932, 0.66991655, 0.78515291, 0.28173011}},
                                      {{0.58641017, 0.06395527, 0.4856276, 0.97749514},
                                       {0.87650525, 0.33815895, 0.96157015, 0.23170163},
                                       {0.94931882, 0.9413777, 0.79920259, 0.63044794},
                                       {0.87428797, 0.29302028, 0.84894356, 0.61787669}},
                                      {{0.01323686, 0.34723352, 0.14814086, 0.98182939},
                                       {0.47837031, 0.49739137, 0.63947252, 0.36858461},
                                       {0.13690027, 0.82211773, 0.18984791, 0.51131898},
                                       {0.22431703, 0.09784448, 0.86219152, 0.97291949}},
                                      {{0.96083466, 0.9065555, 0.77404733, 0.33314515},
                                       {0.08110139, 0.40724117, 0.23223414, 0.13248763},
                                       {0.05342718, 0.72559436, 0.01142746, 0.77058075},
                                       {0.14694665, 0.07952208, 0.08960303, 0.67204781}},
                                      {{0.24536721, 0.42053947, 0.55736879, 0.86055117},
                                       {0.72704426, 0.27032791, 0.1314828, 0.05537432},
                                       {0.30159863, 0.26211815, 0.45614057, 0.68328134},
                                       {0.69562545, 0.28351885, 0.37992696, 0.18115096}},
                                      {{0.78854551, 0.05684808, 0.69699724, 0.7786954},
                                       {0.77740756, 0.25942256, 0.37381314, 0.58759964},
                                       {0.2728219, 0.3708528, 0.19705428, 0.45985588},
                                       {0.0446123, 0.79979588, 0.07695645, 0.51883515}},
                                      {{0.3068101, 0.57754295, 0.95943334, 0.64557024},
                                       {0.03536244, 0.43040244, 0.51001685, 0.53617749},
                                       {0.68139251, 0.2775961, 0.12886057, 0.39267568},
                                       {0.95640572, 0.18713089, 0.90398395, 0.54380595}},
                                      {{0.45691142, 0.88204141, 0.45860396, 0.72416764},
                                       {0.39902532, 0.90404439, 0.69002502, 0.69962205},
                                       {0.3277204, 0.75677864, 0.63606106, 0.24002027},
                                       {0.16053882, 0.79639147, 0.9591666, 0.45813883}},
                                      {{0.59098417, 0.85772264, 0.45722345, 0.95187448},
                                       {0.57575116, 0.82076712, 0.90884372, 0.81552382},
                                       {0.15941446, 0.62889844, 0.39843426, 0.06271295},
                                       {0.42403225, 0.25868407, 0.84903831, 0.03330463}},
                                      {{0.95898272, 0.35536885, 0.35670689, 0.0163285},
                                       {0.18523233, 0.4012595, 0.92929142, 0.09961493},
                                       {0.94530153, 0.86948853, 0.4541624, 0.32670088},
                                       {0.23274413, 0.61446471, 0.03307459, 0.01560606}}}}; // (1, 24, 4, 4)
  torch::Tensor transformations =
      torch::from_blob(transformations_.data(), {BATCH_SIZE, JOINT_NUM, 4, 4}).to(m__device);

  /**correct results
   *
   * - vertices: (1, 1, 1)
   *      [
   *          [
   *              [1.077754, 1.091551, 1.083642]
   *          ]
   *      ]
   *
   */

  torch::Tensor vertices;
  try
  {
    LinearBlendSkinning linearBlendSkinning;
    linearBlendSkinning.setDevice(m__device);

    linearBlendSkinning.setWeight(weights);
    linearBlendSkinning.setRestShape(restShape);
    linearBlendSkinning.setTransformation(transformations);

    linearBlendSkinning.skinning();

    vertices = linearBlendSkinning.getVertex();
  }
  catch(std::exception & e)
  {
    std::cerr << e.what() << std::endl;
  }

  std::cout << "posed vertices: " << vertices.sizes() << std::endl; // (N, 6890, 3)
  std::cout << vertices << std::endl;

  std::cout << "PASS!" << std::endl;
  std::cout << "------------------------------------------------" << std::endl;

  BATCH_SIZE = batchSize;
  VERTEX_NUM = vertexNum;

  return;
}

//=============================================================================
} // namespace smpl
//=============================================================================
